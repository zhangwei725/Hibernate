# 常用方法的区别

## 1 session get和load方法

```
1. 对于Hibernate get方法，Hibernate会确认一下该id对应的数据是否存在，首先在session缓存中查找，然后在二级缓存中查找，还没有就查询数据库，数据 库中没有就返回null。
1. Hibernate load方法加载实体对象的时候，根据映射文件上类级别的lazy属性的配置(默认为true)，分情况讨论：
(1)若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则使用延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)。等到具体使用该对象(除获取OID以外)的时候，再查询二级缓存和数据库，若仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。
(2)若为false,就跟Hibernateget方法查找顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException。
```



这里get和load有两个重要区别:

> 如果未能发现符合条件的记录，Hibernate get方法返回null，而load方法会抛出一个ObjectNotFoundException。
>
> load方法可返回没有加载实体数据的代 理类实例，而get方法永远返回有实体数据的对象。
>
> 总之对于get和load的根本区别，一句话，hibernate对于 load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方 法，hibernate一定要获取到真实的数据，否则返回null。

## 2 session对象的evict()和clear()的区别、refresh()和flush()的区别。

```
flush() flush只会操作持久化状态的对象，或者说只会操作一级缓存中的对象。flush只是执行了sql语句，但没有执行commit方法。对于临时对象和游离对象不做任何操作。
refresh() 和flush类似，只不过是方向相反。flush是把session缓存中的对象往数据库中更新，而refresh是把数据库中的对象往session缓存中更新。
 evict() 该方法是从一级缓存中把持久化对象移除。
clear() 清理session中的所有缓存
```


## 3 inverse 和casecade

1. inverse的值是boolean值，也就是能设置为true或false。 如果一方的映射文件中设置为true，说明在映射关系(一对多，多对多等)中让对方来维护关系。如果为false，就自己来维护关系。默认值是false。 并且这属性只能在一端设置。比如一对多，这个一端。也就是在有set集合的这方设置。

2. 维护关系：维护什么关系呢？包括两个方面

   1. 也就是维护外键的关系了，通俗点讲，就是哪一方去设置这个被外键约束的字段的值。就拿上面这个例子来说，order和user两张表不管进行什么操作，只要关系到了另一张表，就不可避免的要通过操作外键字段，比如，order订单号查询用户，就得通过被外键约束的字段值到用户中的主键中查找，如果用户想查询自己部门中有哪些员工，就拿着自己的主键值跟order中的外键字段做比较。 这个是查询操作， 现在如果是添加操作呢，order表中添加一条记录，并且这个订单属于用户表中的一个，order中有被外键约束修饰的字段，那是通过order表的insert语句就对这个外键字段赋值，还是让user对象使用update语句对其赋值呢，两个都能对这个外键字段的值进行操作，谁去操作呢？如果不做设置，两个都会操作，虽然不会出现问题，但是会影响性能，因为order操作的话，在使用insert语句就能设置外键字段的值了，但是user也会进行对其进行操作，又使用update语句，这样一来，这个update就显的很多余。
   2. 维护级联的关系，也就是说如果如果让对方维护关系，则自己方的级联将会失效，对方设置的级联有用，如果自己维护关系，则自己方的级联会有用，但是对方设置的级联就会失效。

3. 总结

   1、inverse的权限在cascade之上，意思就是cascade是否有用，还得看inverse这个属性

   2、inverse的作用：在映射关系中，让其中一方去维护关系，好处就是能提高性能，不用重复维护。维护两种关系，看下

   　　2.1 控制级联关系是否有效cascade是否有效，就得看inserve的值，如果是自己方来维护关系，那么cascade就有效，反之无效

   　　2.2 控制外键关系这个就得通过让自己拥有对方的实例引用(可能是set，也可能就是单个存储对象的变量)，这样才具备控制外键关系的能力，然后看inserve的值，

   3、inverse只能在一的一方设置，并且默认值是true，也就是说，不设置inverse时，默认是让多的一方去维护关系，这种一般是在双向、外键关系中才设置inverse的值，如果是单向的，就只有一方有维护关系的权利。

   4、在以后的代码中，先要搞清楚关系，才能写出性能最好的代码。通过学习这两个属性，在测试代码中，就不必那么麻烦了，只需要考虑维护关系的一方，另一方就会自动保存了。

4. ​





